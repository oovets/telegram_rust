#!/usr/bin/env python3
"""
Telegram Terminal Client - A TUI client for Telegram
"""

import asyncio
import os
import json
import re
import sys
import threading
import urllib.request
import urllib.parse
from datetime import datetime
from typing import Optional, Dict, List

try:
    _script_dir = os.path.dirname(os.path.abspath(__file__))
except NameError:
    _script_dir = os.getcwd()
LOG_FILE = os.path.join(_script_dir, "telegram_client.log")

def debug_log(message: str):
    print(message, file=sys.stderr, flush=True)
    try:
        log_file = LOG_FILE
        log_dir = os.path.dirname(log_file)
        if log_dir and not os.path.exists(log_dir):
            os.makedirs(log_dir, exist_ok=True)
        with open(log_file, "a", encoding="utf-8") as f:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"[{timestamp}] {message}\n")
            f.flush()
    except Exception as e:
        print(f"DEBUG: Could not write to log file ({LOG_FILE}): {e}", file=sys.stderr, flush=True)

from textual.app import App, ComposeResult
from textual.containers import Horizontal, Vertical, ScrollableContainer
from textual.widgets import Header, Input, Static, ListView, ListItem
from textual.binding import Binding
from textual.message import Message

from telethon import TelegramClient, events
from telethon.tl.types import User, Chat, Channel
from telethon.errors import SessionPasswordNeededError


class ChatListItem(ListItem):
    def __init__(self, chat_id: int, chat_info: Dict, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.chat_id = chat_id
        self.chat_info = chat_info

    def compose(self):
        name = self.chat_info['name']
        unread = self.chat_info.get('unread', 0)
        username = self.chat_info.get('username', '')
        safe_name = name.replace("[", "\\[")
        if unread > 0:
            display_text = f"[reverse] {safe_name} ({unread}) [/reverse]"
        else:
            display_text = f" {safe_name}"
        if username:
            display_text += f" {username}"
        yield Static(display_text)


class ChatSelected(Message):
    def __init__(self, chat_id: int):
        super().__init__()
        self.chat_id = chat_id


class ReplyToMessage(Message):
    def __init__(self, message_id: int):
        super().__init__()
        self.message_id = message_id


class MessageView(Vertical):
    def compose(self):
        yield Static("", id="chat-header")
        yield ScrollableContainer(Static("Select a conversation...", id="messages-content"), id="messages-container")

    def set_chat_header(self, name: str, username: str = ""):
        header_widget = self.query_one("#chat-header", Static)
        header_text = name
        if username:
            header_text += f" {username}"
        header_widget.update(header_text)

    def set_messages(self, text: str):
        content = self.query_one("#messages-content", Static)
        content.update(text)
        def scroll(_delay=None):
            try:
                container = self.query_one("#messages-container", ScrollableContainer)
                container.scroll_end(animate=False)
            except:
                pass
        self.call_later(scroll, 0.2)


class ChatList(Vertical):
    BINDINGS = [
        Binding("j", "cursor_down", "Down", show=False),
        Binding("k", "cursor_up", "Up", show=False),
        Binding("enter", "select_chat", "Select", show=False),
    ]

    def on_list_view_selected(self, event: ListView.Selected):
        if isinstance(event.item, ChatListItem):
            self.post_message(ChatSelected(event.item.chat_id))

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.chat_list_view: Optional[ListView] = None
        self.chats: Dict[int, Dict] = {}
        self.chat_items: Dict[int, ChatListItem] = {}

    def compose(self):
        yield Static("Chats", classes="sidebar-header")
        yield ListView(id="chat-list")

    def on_mount(self):
        self.chat_list_view = self.query_one("#chat-list", ListView)

    def update_chats(self, chats: Dict[int, Dict]):
        self.chats = chats
        self.chat_items.clear()
        try:
            list_view = self.query_one("#chat-list", ListView)
            if list_view is not None:
                self.chat_list_view = list_view
            else:
                return
        except Exception:
            return

        try:
            self.chat_list_view.clear()
            if len(chats) == 0:
                return

            def get_sort_key(item):
                chat_info = item[1]
                last_msg = chat_info.get('last_message')
                if last_msg and hasattr(last_msg, 'date'):
                    return last_msg.date
                return datetime.min.replace(tzinfo=None)

            sorted_chats = sorted(chats.items(), key=get_sort_key, reverse=True)
            for chat_id, chat_info in sorted_chats:
                try:
                    item = ChatListItem(chat_id, chat_info)
                    self.chat_items[chat_id] = item
                    self.chat_list_view.append(item)
                except Exception:
                    pass

            self.chat_list_view.refresh()
        except Exception as e:
            debug_log(f"ERROR: Failed to update chat list: {e}")

    def get_selected_chat_id(self) -> Optional[int]:
        if not self.chat_list_view:
            return None
        highlighted = self.chat_list_view.highlighted
        if highlighted is not None and highlighted < len(self.chat_list_view.children):
            item = self.chat_list_view.children[highlighted]
            if isinstance(item, ChatListItem):
                return item.chat_id
        return None

    def action_cursor_down(self):
        if self.chat_list_view:
            self.chat_list_view.action_cursor_down()

    def action_cursor_up(self):
        if self.chat_list_view:
            self.chat_list_view.action_cursor_up()

    def action_select_chat(self):
        chat_id = self.get_selected_chat_id()
        if chat_id:
            self.post_message(ChatSelected(chat_id))


class TelegramApp(App):
    CSS = """

    #sidebar {
        width: 30;
        border-right: solid grey;
    }

    .sidebar-header {
        padding: 0 1;
        text-style: bold;
        color: white;
        height: 1;
    }

    #chat-list {
        height: 1fr;
        scrollbar-size: 0 0;
    }

    ChatListItem {
        height: 1;
        padding: 0 1;
    }

    ListView > .list-view--highlight {
        background: grey;
    }

    #main-content {
        width: 1fr;
    }

    #chat-header {
        padding: 0 1;
        text-style: bold;
        color: white;
        height: 1;
    }

    #messages-container {
        height: 1fr;
        padding: 0 1;
        scrollbar-size: 0 0;
    }

    #messages-content {
        width: 1fr;
    }

    MessageView {
        height: 1fr;
    }

    #input-container {
        height: auto;
        min-height: 3;
        max-height: 5;
        border-top: solid grey;
    }

    #reply-preview {
        width: auto;
        max-width: 50;
        height: auto;
        display: none;
        text-style: italic;
        color: grey;
        padding: 0 1;
    }

    #reply-preview.visible {
        display: block;
    }

    #message-input {
        width: 1fr;
    }

    """

    BINDINGS = [
        Binding("ctrl+q", "quit", "Quit", priority=True),
        Binding("ctrl+r", "refresh", "Refresh", priority=True),
        Binding("ctrl+l", "clear", "Clear", priority=True),
        Binding("tab", "focus_input", "Focus input", priority=True),
    ]

    TITLE = "Telegram Terminal Client"

    def __init__(self):
        super().__init__()
        script_dir = os.path.dirname(os.path.abspath(__file__))
        self.session_file = os.path.join(script_dir, "telegram_session.session")
        self.config_file = os.path.join(script_dir, "telegram_config.json")

        self.api_id = None
        self.api_hash = None
        self.client: Optional[TelegramClient] = None
        self.telegram_loop: Optional[asyncio.AbstractEventLoop] = None
        self.telegram_thread: Optional[threading.Thread] = None

        self.current_chat: Optional[int] = None
        self.chats: Dict[int, Dict] = {}
        self.messages: Dict[int, List] = {}
        self.current_msg_data: list = []  # current chat's (msg, sender_name, is_out) tuples
        self.reply_to_message: Optional[int] = None
        self.running = True

        self.load_config()

    def load_config(self):
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    self.api_id = config.get('api_id')
                    self.api_hash = config.get('api_hash')
            except Exception:
                pass

    def save_config(self):
        try:
            with open(self.config_file, 'w') as f:
                json.dump({'api_id': self.api_id, 'api_hash': self.api_hash}, f)
        except Exception:
            pass

    def compose(self) -> ComposeResult:
        yield Header(show_clock=True)
        with Horizontal():
            yield ChatList(id="sidebar")
            with Vertical(id="main-content"):
                yield MessageView(id="message-view")
                with Horizontal(id="input-container"):
                    yield Static("", id="reply-preview")
                    yield Input(placeholder="Type a message... (/reply N to reply)", id="message-input")
        # No footer

    async def on_mount(self):
        await self.connect_telegram()
        def focus_input(_delay=None):
            try:
                self.query_one("#message-input", Input).focus()
            except:
                pass
        self.call_later(focus_input, 0.5)

    async def connect_telegram(self):
        if not self.api_id or not self.api_hash:
            await self.show_api_dialog()
            return
        def run_telegram_loop():
            self.telegram_loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.telegram_loop)
            try:
                self.telegram_loop.run_until_complete(self._connect_worker())
                self.telegram_loop.run_forever()
            except Exception as e:
                debug_log(f"ERROR: Telegram loop error: {e}")
        self.telegram_thread = threading.Thread(target=run_telegram_loop, daemon=True)
        self.telegram_thread.start()

    async def show_api_dialog(self):
        self.notify("Enter API credentials in the terminal", severity="warning")

    async def _connect_worker(self):
        try:
            debug_log("DEBUG: _connect_worker starting")
            self.client = TelegramClient(self.session_file, self.api_id, self.api_hash)
            await self.client.start()
            debug_log("DEBUG: Client started")

            is_authorized = await self.client.is_user_authorized()
            if not is_authorized:
                self.notify("Not logged in. Check terminal.", severity="warning")
                return

            me = await self.client.get_me()
            debug_log(f"DEBUG: Logged in as {me.first_name}")
            self.call_from_thread(lambda: self.notify(f"Logged in as {me.first_name}", severity="success"))

            await self.load_conversations()
            self.client.add_event_handler(self.on_new_message, events.NewMessage)
            debug_log("DEBUG: _connect_worker done")
        except Exception as e:
            import traceback
            debug_log(f"ERROR: Connection error: {e}")
            debug_log(traceback.format_exc())

    async def load_conversations(self):
        if not self.client:
            return
        try:
            dialogs = await self.client.get_dialogs(limit=100)
            self.chats.clear()
            for dialog in dialogs:
                entity = dialog.entity
                chat_id = entity.id
                if isinstance(entity, User):
                    name = entity.first_name or ""
                    if entity.last_name:
                        name += f" {entity.last_name}"
                    if not name:
                        name = f"User {chat_id}"
                    username = f"@{entity.username}" if entity.username else ""
                elif isinstance(entity, (Chat, Channel)):
                    name = entity.title or f"Chat {chat_id}"
                    username = f"@{entity.username}" if hasattr(entity, 'username') and entity.username else ""
                else:
                    name = f"Unknown {chat_id}"
                    username = ""
                self.chats[chat_id] = {
                    'name': name, 'username': username, 'entity': entity,
                    'unread': dialog.unread_count, 'last_message': dialog.message
                }
            chats_dict = self.chats.copy()
            def update_sidebar():
                try:
                    sidebar = self.query_one("#sidebar", ChatList)
                    sidebar.update_chats(chats_dict)
                except Exception as e:
                    debug_log(f"ERROR: UI update failed: {e}")
            self.call_from_thread(update_sidebar)
        except Exception as e:
            debug_log(f"ERROR: Failed to load conversations: {e}")

    def on_chat_selected(self, event: ChatSelected):
        self.current_chat = event.chat_id
        self.reply_to_message = None
        self._hide_reply_preview()
        self.schedule_load_messages(event.chat_id)

    def _mark_chat_read(self, chat_id: int):
        if chat_id in self.chats:
            self.chats[chat_id]['unread'] = 0
        try:
            chat_list = self.query_one("#chat-list", ListView)
            for item in chat_list.children:
                if hasattr(item, 'chat_id') and item.chat_id == chat_id:
                    name = self.chats[chat_id]['name']
                    safe_name = name.replace("[", "\\[")
                    username = self.chats[chat_id].get('username', '')
                    display_text = f" {safe_name}"
                    if username:
                        display_text += f" {username}"
                    item.query_one(Static).update(display_text)
                    break
        except Exception as e:
            debug_log(f"ERROR: Failed to mark chat read: {e}")

    def _hide_reply_preview(self):
        try:
            rp = self.query_one("#reply-preview", Static)
            rp.update("")
            rp.remove_class("visible")
        except:
            pass

    def _show_reply_preview(self, text: str):
        try:
            rp = self.query_one("#reply-preview", Static)
            rp.update(text)
            rp.add_class("visible")
        except:
            pass

    def on_reply_to_message(self, event: ReplyToMessage):
        self.reply_to_message = event.message_id
        for item in self.current_msg_data:
            msg, sender_name = item[0], item[1]
            if msg.id == event.message_id:
                preview = msg.text[:50] if msg.text else "[Media]"
                if len(msg.text or "") > 50:
                    preview += "..."
                self._show_reply_preview(f"Reply to: {preview}")
                try:
                    self.query_one("#message-input", Input).focus()
                except:
                    pass
                break

    def _wrap_text(self, text: str, indent: int, width: int) -> str:
        if width <= indent:
            return text
        content_width = width - indent
        pad = " " * indent
        result_lines = []
        for i, paragraph in enumerate(text.split("\n")):
            if not paragraph:
                result_lines.append(pad if i > 0 else "")
                continue
            chunks = [paragraph[j:j + content_width] for j in range(0, len(paragraph), content_width)]
            for ci, chunk in enumerate(chunks):
                if i == 0 and ci == 0:
                    result_lines.append(chunk)
                else:
                    result_lines.append(pad + chunk)
        return "\n".join(result_lines)

    def _shorten_url(self, url: str) -> str:
        try:
            api_url = f"https://is.gd/create.php?format=simple&url={urllib.parse.quote(url, safe='')}"
            req = urllib.request.Request(api_url, headers={"User-Agent": "TelegramTUI/1.0"})
            with urllib.request.urlopen(req, timeout=3) as resp:
                short = resp.read().decode().strip()
                if short.startswith("http"):
                    return short
        except Exception:
            pass
        return url

    _url_cache: dict = {}

    def _shorten_urls_in_text(self, text: str) -> str:
        url_pattern = re.compile(r'https?://\S{40,}')
        def replacer(match):
            url = match.group(0)
            if url not in self._url_cache:
                self._url_cache[url] = self._shorten_url(url)
            return self._url_cache[url]
        return url_pattern.sub(replacer, text)

    def _get_media_label(self, msg) -> str:
        if msg.photo:
            return "[Photo]"
        elif msg.video:
            return "[Video]"
        elif msg.audio:
            return "[Audio]"
        elif msg.voice:
            return "[Voice message]"
        elif msg.video_note:
            return "[Video note]"
        elif msg.sticker:
            return "[Sticker]"
        elif msg.gif:
            return "[GIF]"
        elif msg.document:
            name = ""
            if hasattr(msg.document, 'attributes'):
                for attr in msg.document.attributes:
                    if hasattr(attr, 'file_name') and attr.file_name:
                        name = attr.file_name
                        break
            return f"[Document: {name}]" if name else "[Document]"
        elif msg.contact:
            return "[Contact]"
        elif msg.geo:
            return "[Location]"
        elif msg.poll:
            return "[Poll]"
        return ""

    def _format_messages(self, msg_data: list) -> str:
        try:
            container = self.query_one("#messages-container", ScrollableContainer)
            width = container.size.width - 2
        except Exception:
            width = 80
        if width < 20:
            width = 80

        lines = []
        for idx, item in enumerate(msg_data):
            msg, sender_name, is_out = item[0], item[1], item[2]
            reply_info = item[3] if len(item) > 3 else None

            media_label = self._get_media_label(msg)
            text = msg.text or ""
            if media_label:
                text = f"{media_label} {text}" if text else media_label
            if not text:
                continue

            timestamp = msg.date.strftime("%H:%M")
            safe_name = sender_name.replace("[", "\\[")
            num_str = f"#{idx + 1}"
            prefix_len = len(num_str) + 1 + len(timestamp) + 1 + len(sender_name) + 2
            text = self._shorten_urls_in_text(text)
            safe_text = text.replace("[", "\\[")
            wrapped = self._wrap_text(safe_text, prefix_len, width)

            if reply_info:
                reply_sender, reply_text = reply_info
                safe_reply_sender = reply_sender.replace("[", "\\[")
                safe_reply_text = reply_text.replace("[", "\\[")
                pad = " " * prefix_len
                lines.append(f"{pad}[dim italic]> {safe_reply_sender}: {safe_reply_text}[/dim italic]")

            num = f"[dim]{num_str}[/dim] "
            if is_out:
                lines.append(f"{num}[dim]{timestamp}[/dim] [bold green]{safe_name}[/bold green]: {wrapped}")
            else:
                lines.append(f"{num}[dim]{timestamp}[/dim] [bold cyan]{safe_name}[/bold cyan]: {wrapped}")
        return "\n".join(lines)

    def _display_messages(self, chat_id: int, msg_data: list):
        try:
            self.current_msg_data = msg_data
            message_view = self.query_one("#message-view", MessageView)
            chat_info = self.chats[chat_id]
            message_view.set_chat_header(chat_info['name'], chat_info['username'])
            message_view.set_messages(self._format_messages(msg_data))
        except Exception as e:
            debug_log(f"ERROR: Display error: {e}")

    async def _resolve_sender_name(self, msg) -> str:
        if msg.out:
            return "You"
        try:
            sender = await msg.get_sender()
            if sender:
                if isinstance(sender, User):
                    name = sender.first_name or ""
                    if sender.last_name:
                        name += f" {sender.last_name}"
                    return name.strip() if name.strip() else "Unknown"
                elif hasattr(sender, 'title') and sender.title:
                    return sender.title
        except Exception as e:
            debug_log(f"DEBUG: Could not resolve sender for msg {msg.id}: {e}")
        return "Unknown"

    async def _load_and_resolve(self, entity, chat_id: int):
        messages = await self.client.get_messages(entity, limit=50)
        # Build id->msg lookup for reply resolution
        msg_by_id = {m.id: m for m in messages}
        # Resolve sender names for all messages first
        sender_cache = {}
        for msg in messages:
            sender_cache[msg.id] = await self._resolve_sender_name(msg)

        # Build msg_data: (msg, sender_name, is_out, reply_info)
        # reply_info is None or (reply_sender_name, reply_preview_text)
        msg_data = []
        for msg in reversed(messages):
            sender_name = sender_cache[msg.id]
            reply_info = None
            if msg.reply_to and hasattr(msg.reply_to, 'reply_to_msg_id') and msg.reply_to.reply_to_msg_id:
                reply_id = msg.reply_to.reply_to_msg_id
                if reply_id in msg_by_id:
                    reply_msg = msg_by_id[reply_id]
                    reply_sender = sender_cache.get(reply_id, "Unknown")
                    reply_text = reply_msg.text[:40] if reply_msg.text else "[Media]"
                    if reply_msg.text and len(reply_msg.text) > 40:
                        reply_text += "..."
                    reply_info = (reply_sender, reply_text)
                else:
                    # Message not in our loaded batch, try to fetch
                    try:
                        reply_msg = await self.client.get_messages(entity, ids=reply_id)
                        if reply_msg:
                            rs = await self._resolve_sender_name(reply_msg)
                            rt = reply_msg.text[:40] if reply_msg.text else "[Media]"
                            if reply_msg.text and len(reply_msg.text) > 40:
                                rt += "..."
                            reply_info = (rs, rt)
                    except:
                        pass
            msg_data.append((msg, sender_name, msg.out, reply_info))
        self.messages[chat_id] = messages
        return msg_data

    def schedule_load_messages(self, chat_id: int):
        if not self.client or chat_id not in self.chats or not self.telegram_loop:
            return
        entity = self.chats[chat_id]['entity']
        async def _load():
            try:
                msg_data = await self._load_and_resolve(entity, chat_id)
                await self.client.send_read_acknowledge(entity)
                self.call_from_thread(lambda: self._display_messages(chat_id, msg_data))
                self.call_from_thread(lambda: self._mark_chat_read(chat_id))
            except Exception as e:
                debug_log(f"ERROR: Failed to load messages: {e}")
        asyncio.run_coroutine_threadsafe(_load(), self.telegram_loop)

    def on_input_submitted(self, event: Input.Submitted):
        if event.input.id == "message-input":
            text = event.value.strip()
            if not text:
                return

            # Handle /reply N command
            if text.startswith("/reply "):
                self._handle_reply_command(text)
                event.input.value = ""
                return

            self.send_message(text)
            event.input.value = ""
            self.reply_to_message = None
            self._hide_reply_preview()
            try:
                event.input.focus()
            except:
                pass

    def _handle_reply_command(self, text: str):
        parts = text.split(maxsplit=1)
        if len(parts) < 2:
            self.notify("Usage: /reply N", severity="warning")
            return
        try:
            num = int(parts[1])
        except ValueError:
            self.notify("Usage: /reply N (where N is the message number)", severity="warning")
            return

        if not self.current_msg_data:
            self.notify("No messages loaded", severity="warning")
            return

        # Find the message with that display number
        # Display numbers are 1-indexed, only counting messages with text
        text_msgs = [(i, item[0]) for i, item in enumerate(self.current_msg_data) if item[0].text]
        if num < 1 or num > len(text_msgs):
            self.notify(f"Message #{num} not found (1-{len(text_msgs)})", severity="warning")
            return

        idx, msg = text_msgs[num - 1]
        sender_name = self.current_msg_data[idx][1]
        self.reply_to_message = msg.id
        preview = msg.text[:50] if msg.text else "[Media]"
        if len(msg.text or "") > 50:
            preview += "..."
        self._show_reply_preview(f"Reply to #{num} ({sender_name}): {preview}")
        self.notify(f"Replying to #{num}. Type your message and press Enter.", severity="info")
        try:
            self.query_one("#message-input", Input).focus()
        except:
            pass

    def send_message(self, text: str):
        if not self.client or not self.current_chat:
            self.notify("Select a conversation first", severity="warning")
            return
        if not self.telegram_loop:
            self.notify("Telegram connection not ready", severity="error")
            return

        chat_id = self.current_chat
        entity = self.chats[chat_id]['entity']
        reply_to_id = self.reply_to_message

        async def _send():
            try:
                if reply_to_id:
                    reply_msg = None
                    if chat_id in self.messages:
                        for msg in self.messages[chat_id]:
                            if msg.id == reply_to_id:
                                reply_msg = msg
                                break
                    if reply_msg:
                        await self.client.send_message(entity, text, reply_to=reply_msg)
                    else:
                        await self.client.send_message(entity, text)
                else:
                    await self.client.send_message(entity, text)

                msg_data = await self._load_and_resolve(entity, chat_id)
                self.call_from_thread(lambda: self._display_messages(chat_id, msg_data))
            except Exception as e:
                debug_log(f"ERROR: Send failed: {e}")

        asyncio.run_coroutine_threadsafe(_send(), self.telegram_loop)

    async def on_new_message(self, event):
        chat_id = event.message.chat_id
        if chat_id not in self.chats:
            return

        if chat_id == self.current_chat:
            try:
                entity = self.chats[chat_id]['entity']
                msg_data = await self._load_and_resolve(entity, chat_id)
                await self.client.send_read_acknowledge(entity)
                self.chats[chat_id]['unread'] = 0
                self.call_from_thread(lambda: self._display_messages(chat_id, msg_data))
            except Exception as e:
                debug_log(f"ERROR: Failed to load in on_new_message: {e}")
        else:
            self.chats[chat_id]['unread'] = self.chats[chat_id].get('unread', 0) + 1
            chat_name = self.chats[chat_id].get('name', 'Unknown')
            preview = event.message.text[:30] if event.message.text else "[Media]"
            def _update_sidebar():
                try:
                    sidebar = self.query_one("#sidebar", ChatList)
                    sidebar.update_chats(self.chats)
                except:
                    pass
            self.call_from_thread(_update_sidebar)
            self.call_from_thread(lambda: self.notify(f"{chat_name}: {preview}", severity="info"))

    def action_refresh(self):
        if self.client:
            self.run_worker(self.load_conversations(), exclusive=False)

    def action_clear(self):
        try:
            message_view = self.query_one("#message-view", MessageView)
            message_view.set_messages("")
        except:
            pass

    def action_focus_input(self):
        self.query_one("#message-input", Input).focus()

    async def action_quit(self):
        if self.client:
            await self.client.disconnect()
        self.exit()


async def main():
    debug_log("=" * 60)
    debug_log("Telegram Client starting...")
    debug_log("=" * 60)

    config_file = "telegram_config.json"
    api_id = None
    api_hash = None

    if os.path.exists(config_file):
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                api_id = config.get('api_id')
                api_hash = config.get('api_hash')
        except:
            pass

    if not api_id or not api_hash:
        print("=" * 60)
        print("Telegram Terminal Client - First time setup")
        print("=" * 60)
        print("\nGet API credentials from: https://my.telegram.org")
        print("Log in and create a new application\n")
        try:
            api_id_str = input("API ID: ").strip()
            api_hash = input("API Hash: ").strip()
            api_id = int(api_id_str)
            with open(config_file, 'w') as f:
                json.dump({'api_id': api_id, 'api_hash': api_hash}, f)
        except (ValueError, KeyboardInterrupt):
            print("\nAborted.")
            return

    app = TelegramApp()
    app.api_id = api_id
    app.api_hash = api_hash
    app.save_config()
    await app.run_async()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nExiting...")
